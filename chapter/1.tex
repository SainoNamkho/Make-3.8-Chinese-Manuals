\chapter{概述}

\section{make概述}

Linux环境下的程序员如果不会使用GNU make来构建和管理自己的工程，应该不能算是一个合格的专业程序员，至少不能称得上是Unix程序员。在Linux（unix）环境下使用GNU 的make工具能够比较容易的构建一个属于你自己的工程，整个工程只需要一个命令就可以完成编译、链接。不过这需要我们投入一些时间去完成一个或者多个称之为Makefile文件的编写。此文件正是make正常工作的基础。

所要完成的Makefile文件描述了整个工程的编译、链接等规则。包括：工程中的哪些源文件需要编译以及如何编译、需要创建那些库文件以及如何创建这些库文件、最终如何创建所期望的可执行文件。看起来这是一件比较复杂的事情（实际也是如此），但为工程编写Makefile的好处是：在完成了管理工程所需的Makefile以后，能够使用一个命令来进行“自动化编译”。对于一个工程（无论大小）来说，在完成了管理它所需要的Makefile以后。编译整个工程只需要在shell下输入make，对所有源文件的编译、库的产生以及可执行文件的链接将自动完成。因此为工程编写Makefile，可谓是一劳永逸！

make是一个命令工具，它解释Makefile中的指令（Makefile中称为规则）。Makefile文件则描述了整个工程所有源文件的编译顺序、编译规则以及编译方法；Makefile有自己的书写格式、关键字、函数，像C语言有自己的格式、关键字和函数一样；在Makefile中可以使用系统shell所提供的命令（包括那些能够在shell环境中运行应用组件），来实现必要的操作。Makefile（在其它的系统上可能是另外的文件名）也是绝大多数IDE开发环境的基础，它已经成为一种工程编译方法。

目前，系统完整介绍make工具和编写Makefile的中文文档较少。我整理这个文档的目的：能使众多Linux环境下的程序员比较容易地掌握和使用GNU make。本文所要介绍的是GNU的make，采用Red Hat FC5（包括最新发布的GNU Linux系统）所集成的GUN make工具。

本文中所有示例均采用C语言源程序，因为它是目前最流行的一种编程语言。当然make工具不仅仅是用来管理C语言工程的，那些编译器只要能够在shell下运行的语言所构建的工程都可以使用make工具来管理。使用GNU make不仅仅可以编译源代码，也可以实现一些其它工作。例如，有这样的需求：当我们修改了某个或者某些文件后，需要能够根据修改文件来自动对其他相关文件进行重建或者更新。那么使用GNU make工具是再合适不过了。GNU make工具为我们实现这个目的提供了非常有利的支持。工程中根据源文件的修改情况来进行代码的编译正是使用了make的这个特征。make执行时，根据Makefile的规则检查相关文件（指的是规则所描述的所有文件，包括规则的目标和依赖）的修改情况，决定是否执行规则所定义命令（通常命令是编译源文件），这是GNU make的执行依据。

\section{准备知识}
在开始关于make的讨论之前，首先了解一些基本概念：

编译：把高级语言书写的代码转换为机器可识别的机器指令（实际编译过程中包含了汇编过程，编译、汇编之后产生真正的机器指令，这里将编译和汇编统称为编译）。编译高级语言后生成的指令虽然可被机器识别，但是还不能被执行。编译时，编译器检查高级语言语法、函数以及变量声明的正确性。在所有的语法正确、相关变量定义正确、函数声明存在的情况下，编译器才可由源文件产生（首先产生汇编代码，之后编译器调用汇编器生成目标文件）出目标文件。通常，一个高级语言的源文件都可对应一个目标文件。目标文件在Linux中默认后缀为“.o”（如“foo.c”的目标文件为“foo.o”）。

为了和规则的目标文件相区别。本文将编译高级语言后生成的目标文件称为.o文件。
 
链接：将多个.o文件、或者一个.o文件和一个（多个）库文件根据链接脚本，组成一个可被操作系统执行的文件（称为可执行文件，Linux下可执行文件通常为“elf”格式）。链接器不检查函数所在的源文件，只检查所有.o文件中定义的符号。将.o文件中使用的符号和其它.o或者库文件中的相关符号进行合并，对这些符号址进行重定位（给这些符号在统一的地址空间中分配具体地址，并使用符号的具体地址替换指令中对符号的引用），最后和系统相关文件关联（程序启动文件，动态库）；最终生成可执行程序。链接过程使用GNU 的“ld”工具。
 
静态库：又称为文档文件（Archive File）。它是多个.o文件的集合。Linux中静态库文件的后缀为“.a”。静态库中的各个成员（.o文件）在库中保持其原来格式。静态库.a文件仅仅是多个.o的集合，同时包含了一些用于维护库本身所需要的信息。使用“ar”工具维护和管理静态库。 
 
共享库：也是多个.o文件的集合，但是这些.o文件是由编译器（链接器）按照一种特殊的方式生成（Linux中，共享库文件格式通常为“elf”格式，共享库已经具备了可执行条件）。模块中各个成员的地址（变量引用和函数调用）都是相对地址。使用一个共享库的程序在加载时，这个共享库也被动态加载到内存并和主程序在内存中进行链接（共享库被加载到内存以后，主程序对共享库所包含符号的引用将被此符号在内存中的地址所替换）。多个可执行程序可共享共享库的代码段（多个程序可以共享的使用库的某一个模块，共享代码，但不共享数据）。另外共享库的成员对象可被独立执行（由libdl.so提供支持）。
关于ld的用法以及连接脚本的书写，请参考ld的在线手册。ar的用法也请参考在线手册。
